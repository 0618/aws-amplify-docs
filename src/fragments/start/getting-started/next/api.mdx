Now that you’ve created and configured a Next.js app and initialized a new Amplify project, you can add a feature. The first feature you will add is an API.

The Amplify CLI supports creating and interacting with two types of API categories: REST and GraphQL.

The API you will be creating in this step is a GraphQL API using AWS AppSync (a managed GraphQL service) and the database will be Amazon DynamoDB (a NoSQL database).

## Create a GraphQL API and database

Add a [GraphQL API](https://docs.aws.amazon.com/appsync/latest/devguide/designing-a-graphql-api.html) to your app and automatically provision a database by running the following command from the root of your application directory:

```bash
amplify add api
```

Select the explicit values below to enable **API key** (for public read access) and **Cognito User Pools** (for authenticated access).

```console
? Select from one of the below mentioned services: GraphQL
? Here is the GraphQL API that we will create. Select a setting to edit or continue Continue
? Choose a schema template: Single object with fields (e.g., “Todo” with ID, name, description)
✔ Do you want to edit the schema now? (Y/n) · yes
```

The CLI should open this GraphQL schema in your text editor.

**amplify/backend/api/nextamplified/schema.graphql**

```graphql
type Post
  @model
  @auth(rules: [{ allow: owner }, { allow: public, operations: [read] }]) {
  id: ID!
  title: String!
  content: String!
}
```

The schema generated is for a blog app. You'll notice a directive on the `Post` type of `@model`. This directive is part of the [GraphQL transform](/cli/graphql/data-modeling) library of Amplify.

The GraphQL Transform Library provides custom directives you can use in your schema that allow you to do things like define data models, set up authentication and authorization rules, configure serverless functions as resolvers, and more.

A type decorated with the `@model` directive will scaffold out the database table for the type (Post table), the schema for CRUD (create, read, update, delete) and list operations, and the GraphQL resolvers needed to make everything work together.

From the command line, press **enter** to accept the schema and continue to the next steps.

### Deploying the API

To deploy this backend, run the `push` command:

```bash
amplify push
```

```console
    Current Environment: dev

┌──────────┬───────────────┬───────────┬───────────────────┐
│ Category │ Resource name │ Operation │ Provider plugin   │
├──────────┼───────────────┼───────────┼───────────────────┤
│ Api      │ nextamplified │ Create    │ awscloudformation │
└──────────┴───────────────┴───────────┴───────────────────┘
? Are you sure you want to continue? Yes
```

Next, you'll be prompted to add a _default authentication and security configuration_:

```console
 Do you want to use the default authentication and security configuration? Default configuration
 How do you want users to be able to sign in? Username
 Do you want to configure advanced settings? No, I am done.
```

Finally, you'll be prompted to generate GraphQL code:

```console
? Do you want to generate code for your newly created GraphQL API Yes
? Choose the code generation language target javascript
? Enter the file name pattern of graphql queries, mutations and subscriptions src/graphql/**/*.js
? Do you want to generate/update all possible GraphQL operations - queries, mutations and subscriptions Yes
? Enter maximum statement depth [increase from default if your schema is deeply nested] 2
```

Now the API is live and you can start interacting with it!

The API you have deployed includes operations for creating, reading, updating, deleting, and listing posts.

You can run the following command to check Amplify's status:

```bash
amplify status
```

This will give us the current status of the Amplify project, including the current environment, any categories that have been created, and what state those categories are in. It should look similar to this:

```console
Current Environment: dev

| Category | Resource name         | Operation | Provider plugin   |
| -------- | --------------------- | --------- | ----------------- |
| Api      | nextamplified         | No Change | awscloudformation |
| Auth     | nextamplifiedXXXXXXXX | No Change | awscloudformation |
```

To view the GraphQL API in the AppSync console at any time, run the following command:

```bash
amplify console api
? Select from one of the below mentioned services: GraphQL
```

To view your entire app in the Amplify console at any time, run the following command:

```bash
amplify console
```

### (Optional) Test your API

To test this out locally, you can run the `mock` command.

> If you'd like to go ahead and connect the front end, you can [jump to the next step](#connect-frontend-to-api).

```bash
amplify mock api
```

_Note:_ `amplify mock api` requires Java.

This will open the GraphiQL explorer on a local port. From the test environment you can try out different operations locally, like queries and mutations.

In the GraphiQL toolbar, select **Use: User Pool** and try creating a post:

```graphql
mutation CreatePost {
  createPost(input: { title: "Test Post", content: "post content" }) {
    id
    owner
    title
    updatedAt
    createdAt
    content
  }
}
```

Next, update auth to **Use: API Key** and try querying the list of posts:

```graphql
query ListPosts {
  listPosts {
    items {
      content
      createdAt
      id
      owner
      title
    }
  }
}
```

<Callout warning={true}>

When you're done using `amplify mock api`, revert your `aws-exports.js` configuration back to your cloud backend:

```bash
amplify pull
```
</Callout>

## API with Server-Side Rendering (SSR)

In this section you will create a way to list and create posts from the Next.js application. To do this, you will fetch & render the latest posts from the server as well as create a new post on the client.

First, open **pages/_app.js** and replace it with the following code:

```jsx
// pages/_app.js

// 1️⃣ Import Amplify dependencies
import { withAuthenticator } from "@aws-amplify/ui-react";
import { Amplify } from "aws-amplify";
import awsExports from "../src/aws-exports";
import "@aws-amplify/ui-react/styles.css";

import "../styles/globals.css";

// 2️⃣ Enable SSR support for Amplify
Amplify.configure({ ...awsExports, ssr: true });

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}

// 3️⃣ Wrap entire app behind authentication
export default withAuthenticator(MyApp);
```

Let's walk through some of this file:

1. **@aws-amplify/ui-react/styles.css`** – The Authenticator is ships with a default theme that can be customized.
2. **Amplify.configure** – For authenticated requests to work on the server, our client has to be configured with `ssr: true` to make credentials available on subsequent requests.
3. **withAuthenticator** – This wraps the entire app in the Authenticator so only authenticated users get access.

Next, open **pages/index.js** and replace it with the following code:

```jsx
// pages/index.js

// 1️⃣ Import `useAuthenticator` so we can call `signOut`
import { useAuthenticator } from "@aws-amplify/ui-react";
// 2️⃣ Import Amplify dependencies
import { API, withSSRContext } from "aws-amplify";
// 3️⃣ Import GraphQL queries to `createPost` and `listPosts`
import { createPost } from "../src/graphql/mutations";
import { listPosts } from "../src/graphql/queries";

import Head from "next/head";
import styles from "../styles/Home.module.css";

// 4️⃣ Fetch exists `posts` from the API on the server
export async function getServerSideProps({ req }) {
  const SSR = withSSRContext({ req });
  let posts = [];

  try {
    const response = await SSR.API.graphql({ query: listPosts });
    posts = response.data.listPosts.items;
  } catch (error) {
    console.warn(error);
  }

  return {
    props: {
      posts,
    },
  };
}

export default function Home({ posts = [] }) {
  const { signOut } = useAuthenticator();

  // 5️⃣ Create a new post by calling the `API` with `createPost`
  const handleCreatePost = async (event) => {
    event.preventDefault();

    const form = new FormData(event.target);

    try {
      const { data } = await API.graphql({
        authMode: "AMAZON_COGNITO_USER_POOLS",
        query: createPost,
        variables: {
          input: {
            title: form.get("title"),
            content: form.get("content"),
          },
        },
      });

      // 6️⃣ Redirect to the new post
      window.location.href = `/posts/${data.createPost.id}`;
    } catch ({ errors }) {
      console.error(...errors);
      throw new Error(errors[0].message);
    }
  };

  return (
    <div className={styles.container}>
      <Head>
        <title>Amplify + Next.js</title>
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>Amplify + Next.js</h1>

        <p className={styles.description}>
          <code className={styles.code}>{posts.length}</code>
          posts
        </p>

        <div className={styles.grid}>
          {posts.map((post) => (
            <a className={styles.card} href={`/posts/${post.id}`} key={post.id}>
              <h3>{post.title}</h3>
              <p>{post.content}</p>
            </a>
          ))}

          <div className={styles.card}>
            <h3 className={styles.title}>New Post</h3>

            <form onSubmit={handleCreatePost}>
              <fieldset>
                <legend>Title</legend>
                <input
                  defaultValue={`Today, ${new Date().toLocaleTimeString()}`}
                  name="title"
                />
              </fieldset>

              <fieldset>
                <legend>Content</legend>
                <textarea
                  defaultValue="I built an Amplify app with Next.js!"
                  name="content"
                />
              </fieldset>

              <button>Create Post</button>
              <button type="button" onClick={signOut}>
                Sign out
              </button>
            </form>
          </div>
        </div>
      </main>
    </div>
  );
}
```

Let's walk through some of this file:

1. **useAuthenticator** – This gives our components access to Authenticator properties like `signOut` and `user`.
2. **withSSRContext** – This is necessary for Amplify to keep credentials scoped to a single request on the server.
3. **createPost** & **listPosts** – These queries were automatically generated by the Amplify CLI.
4. **getServerSideProps** – For each request (`req`) on the server, we create a copy of Amplify (called `SSR` here from `withSSRContext({ req })`) that scopes credentials, data, and storage to _just one_ request. `API.graphql` queries for a list of posts, and returns them as the `posts` prop for the `Home` component.
5. **handleCreatePost** – This function is called when a logged-in user submits our "New Post" form. `API.graphql` is called to create the new post's `title` and `content`. Once created, we redirect to `/posts/${post.id}`. Notice that we explicitly set `authMode` to `AMAZON_COGNITO_USER_POOLS`. This is because our `schema.graphql` explicitly requires an authorized user to create/delete/update our **Post** model. Based on our configuration when we ran `amplify add api`, this value is defaulting to `API_KEY`.
6. Once a post is created, we redirect to `/posts/${post.id}`.

Next, let's build our `Post` page.

## API with Incremental Static Site Generation (SSG)

Statically generating pages during the build process improves performance. But, dynamically created posts still need to not `404`.

To solve this, create **pages/posts/[id].js** and paste in the following content:

```jsx
// pages/posts/[id].js

// 1️⃣ Import Amplify dependencies
import { API, withSSRContext } from "aws-amplify";
import { deletePost } from "../../src/graphql/mutations";
import { getPost, listPosts } from "../../src/graphql/queries";

import Head from "next/head";
import styles from "../../styles/Home.module.css";

// 2️⃣ Statically generate all existing posts at build-time
export async function getStaticPaths() {
  const SSR = withSSRContext();
  const { data } = await SSR.API.graphql({ query: listPosts });
  const paths = data.listPosts.items.map((post) => ({
    params: { id: post.id },
  }));

  return {
    fallback: "blocking",
    paths,
  };
}

// 3️⃣ Fetch & return post from API by `id`, or 404 if not found
export async function getStaticProps({ params }) {
  const SSR = withSSRContext();
  let post;

  try {
    const response = await SSR.API.graphql({
      query: getPost,
      variables: {
        id: params.id,
      },
    });

    post = response.data.getPost;
  } catch (error) {
    console.warn(error);
  }

  if (!post) {
    return {
      notFound: true,
    };
  }

  return {
    props: {
      post,
    },
  };
}

export default function Post({ post }) {
  // 4️⃣ `deletePost` by `post.id` and redirect back to `/`
  const handleDelete = async () => {
    try {
      await API.graphql({
        authMode: "AMAZON_COGNITO_USER_POOLS",
        query: deletePost,
        variables: {
          input: { id: post.id },
        },
      });

      window.location.href = "/";
    } catch ({ errors }) {
      console.error(...errors);
      throw new Error(errors[0].message);
    }
  };

  return (
    <div className={styles.container}>
      <Head>
        <title>{post.title} – Amplify + Next.js</title>
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>{post.title}</h1>

        <p className={styles.description}>{post.content}</p>
      </main>

      <footer className={styles.footer}>
        <button onClick={handleDelete}>💥 Delete post</button>
      </footer>
    </div>
  );
}
```

Let's walk through some of this file:

1. **Queries & Mutations** – We `listPosts` to statically generate pages at build-time, `getPost` to fetch a post by `id`, and `deletePost` to delete a post.
2. **getStaticPaths** – This function is called during the build process to statically generate all existing posts.
3. **getStaticProps** – This function is called during the build process to fetch a post by `id`.
4. **handleDelete** – This function is called when a logged-in user clicks the "Delete Post" button. `API.graphql` is called to delete the post.

## Testing SSG

With your server running (`npm run dev`), refresh the page (or go back home to <http://localhost:3000/> and click into a post) and you'll see a page for this post!
