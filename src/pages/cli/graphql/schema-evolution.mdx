export const meta = {
  title: `Evolving GraphQL Schemas`,
  description: `Evolve your GraphQL schema over time using the @mapsTo directive to retain tables while renaming models`,
};

# Renaming Models while retaining data

Amplify supports renaming models in a GraphQL schema by using the `@mapsTo` directive.
Normally when renaming a model, Amplify will remove the underlying table for the model and create a new table with the new name. However, once in production, tables cannot be deleted but GraphQL schemas still evolve.
Using `@mapsTo`, the original model name of a model can be specified when renaming a model. Amplify will use the original name to ensure the underlying DynamoDB tables and other resources point to the original data.
The schema and other API references to the model will use the new name.

```graphql
type Todo @model {
  id: ID!
  title: String!
}
```
becomes
```graphql
type Task @model @mapsTo(name: "Todo") {
  id: ID!
  title: String!
}
```
Amplify will update all of the GraphQL operations and types to use the new name, but the Task model will point to the same table that Todo was originally using.

<Callout>

`@mapsTo` cannot be used to point a model to an arbitrarily named table. It can only be used to point a renamed model to it's original name
</Callout>

When renaming a model that has relationships with other models, Amplify will automatically map auto-generated foreign key fields to their original name. For example, given:

```graphql
type Post @model {
  id: ID!
  title: String!
  comments: [Comment] @hasMany
}

type Comment @model {
  id: ID!
  message: String!
  # postCommentsId: String is an autogenerated field containing the foreign key
}
```
Amplify will automatically add a field named `postCommentsId` to the Comment model that contains the foreign key of the Post. If the Post type is renamed to Article:

```graphql
type Article @model @mapsTo(name: "Post") {
  id: ID!
  title: String!
  comments: [Comment] @hasMany
}

type Comment @model {
  id: ID!
  message: String!
  # articleCommentsId: String is the new autogenerated field containing the foreign key
}
```
the underlying table still contains records with `postCommentsId` as the foreign key fields in the Comment table. In the generated schema the foreign key field is now `articleCommentsId`.
Amplify is aware of this and will automatically map incoming requests with `articleCommentsId` to `postCommentsId` and do the reverse mapping for results.

## Limitations 
There are some cases where the original foreign key field name must still be used. In list FilterInput and update ConditionInput objects, the original key name must be used because these inputs are passed directly to the DynamoDB operation. Likewise, the FilterInput for a search query must also use the original field name.
In these cases, the result will still have the fields mapped to the new name.

Also note that in the above example if you renamed Comment to Reaction:
```graphql
type Post @model {
  id: ID!
  title: String!
  comments: [Reaction] @hasMany # this field cannot be renamed and still access existing relationship data
}

type Reaction @model @mapsTo(name: "Comment") {
  id: ID!
  message: String!
  # autogenerated field postCommentsId: String contains the foreign key
}
```
The `@hasMany` field `comments` cannot be renamed to `reactions`. This is because the foreign key field in Reaction uses the parent field name as part of the name. Amplify cannot determine the original name if this is changed.